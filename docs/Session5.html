<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fa" xml:lang="fa" dir="rtl"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>session5 – درس هوش مصنوعی</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-fa4b1673990fa3f7be976ac11d59a17c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="style.css">
</head>

<body class="quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><h1 style="text-align: center;" class="title display-7">
جلسه ۵: مهندسی پرامپت (متدولوژی ساختارمند، پیشرفته و گسترده)
</h1></header>




<div style="text-align: center; margin-top: 2rem;">

<h2 class="anchored">
تحلیل عمیق معماری پرامپت، استدلال زنجیره‌ای (CoT)، Few-shot، ساختاردهی خروجی و جزئیات پارامترهای تولید
</h2>
<p style="color: var(--color-text-muted); font-size: 1.1rem;">
بررسی جزئیات مدل شش‌گانه HARDER، مکانیسم‌های Grounding و ضدتوهم، شبه‌کدهای RAG-ICL و مدیریت دقیق پارامترهای دما (Temperature) و Top-P.
</p>
<hr style="width: 60%; margin: 2rem auto;">
</div>
<section class="section-card">
<h3 id="section-1" class="anchored">
بخش اول: مبانی نظری، ماهیت آماری، فلسفه و تاریخچه Prompt Engineering
</h3>
<p style="color: var(--color-text-muted); font-size: 1.1rem;">
تحلیل جامع ریشه‌های مدل‌های ترانسفورمر، پرامپت به عنوان یک <strong>توزیع احتمال شرطی دینامیک</strong> و بررسی فلسفه <strong>برنامه‌نویسی شناختی</strong> و تاریخچه ICL با جزئیات فنی.
</p>
<h4 id="section-1-1" class="anchored">
۱.۱. ماهیت آماری و ریاضی LLMs و تئوری برنامه‌نویسی غیرمستقیم
</h4>
<dl>
<dt>
تحلیل احتمال مشترک و نقش پرامپت در فضای لاجیت
</dt>
<dd>
<p>
LLMs مدل‌هایی بر پایه معماری ترانسفورمر هستند که توزیع احتمال مشترک <span class="math inline">\(\mathcal{P}(\mathbf{t}_1, \ldots, \mathbf{t}_n)\)</span> یک دنباله از توکن‌ها را محاسبه می‌کنند. پرامپت <span class="math inline">\((\mathbf{t}_1, \ldots, \mathbf{t}_i)\)</span> به عنوان <strong>شرط (Condition)</strong> اولیه عمل کرده و این توزیع را محدود می‌سازد.
</p>
<p>
انتخاب توکن بعدی <span class="math inline">\((\mathbf{t}_{i+1})\)</span> بر اساس حداکثرسازی احتمال شرطی (Maximum Likelihood) است. این فرآیند بر روی بردار <strong>لاجیت (Logit Vector)</strong> <span class="math inline">\(\mathbf{z}_{i+1}\)</span> انجام می‌شود. مهندسی پرامپت، با تنظیم ورودی، لاجیت‌های مربوط به توکن‌های خروجی مطلوب را به سمت مقادیر بالاتر سوق می‌دهد:
</p>
<span class="math display">\[
    \mathbf{t}_{i+1}^* = \underset{\mathbf{t}_{i+1}}{\operatorname{argmax}} \, P(\mathbf{t}_{i+1} | \mathbf{t}_1, \ldots, \mathbf{t}_i, \theta) = \underset{\mathbf{t}_{i+1}}{\operatorname{argmax}} \, \text{Softmax}(\mathbf{z}_{i+1})
    \]</span>
</dd>
<dt>
نقش پرامپت در مکانیسم Self-Attention و فعال‌سازی هدفمند
</dt>
<dd>
<p>
در هر لایه ترانسفورمر، پرامپت به عنوان ورودی برای محاسبه <strong>Query (Q)</strong>، <strong>Key (K)</strong> و <strong>Value (V)</strong> استفاده می‌شود. پرامپت یک <strong>فاز فعال‌سازی هدفمند (Targeted Activation Phase)</strong> است که وزن‌های توجه (Attention Weights) را محاسبه می‌کند:
</p>
<span class="math display">\[
    \text{Attention}(\mathbf{Q}, \mathbf{K}, \mathbf{V}) = \text{Softmax} \left( \frac{\mathbf{Q} \mathbf{K}^T}{\sqrt{d_k}} \right) \mathbf{V}
    \]</span>
<p>
مهندسی پرامپت باعث می‌شود که توکن‌های پرسش و دستورالعمل، <strong>وزن بالاتری</strong> را به دانش ذخیره‌شده مرتبط در پارامترهای مدل اختصاص دهند، در نتیجه فرآیند استدلال بهینه‌سازی می‌شود.
</p>
</dd>
</dl>
<h4 id="section-1-2" class="anchored">
۱.۲. فلسفه برنامه‌نویسی شناختی و نقاط عطف اصلی ICL و CoT
</h4>
<dl>
<dt>
برنامه‌نویسی غیرمستقیم (Indirect Programming) و Meta-Learning
</dt>
<dd>
<p>
Prompt Engineering نوعی <strong>برنامه‌نویسی شناختی (Cognitive Programming)</strong> است. به جای کدگذاری الگوریتم‌ها، ما با زبان طبیعی، <strong>رفتار، فرآیند فکری و استراتژی</strong> مطلوب را از مدل استخراج می‌کنیم. این فرآیند <strong>تنظیم دقیق مجازی (Virtual Fine-Tuning)</strong> نامیده می‌شود که در آن مدل با استفاده از مثال‌های درون متنی (ICL)، یک فرآیند <strong>Meta-Learning</strong> را فعال می‌کند.
</p>
</dd>
<dt>
نقاط عطف تاریخی و تکامل تکنیک‌ها
</dt>
<dd>
<ul>
<li>
<strong>GPT-3 و ICL (2020):</strong> معرفی <strong>In-Context Learning (ICL)</strong>. این قابلیت نشان داد که مدل‌های مقیاس بزرگ می‌توانند تنها با چند مثال، وظایف جدید را بدون نیاز به به‌روزرسانی وزن‌ها انجام دهند.
</li>
<li>
<strong>Chain-of-Thought (CoT) (2022):</strong> کشف متدی که مدل را وادار به توضیح مراحل استدلال می‌کند (<span class="math inline">\(\mathbf{x} \to \text{Thought}_1 \to \ldots \to \mathbf{y}\)</span>). این نقطه عطف، قابلیت حل مسائل <strong>چندمرحله‌ای، منطقی و ریاضی</strong> را با دقت بسیار بالاتر بهبود بخشید.
</li>
</ul>
</dd>
</dl>
</section>
<section class="section-card">
<h3 id="section-2" class="anchored">
بخش دوم: چالش‌های بنیادین LLMs و الزامات پرامپت‌های مقاوم (Robustness)
</h3>
<p style="color: var(--color-text-muted); font-size: 1.1rem;">
مدیریت عمیق توهم، کنترل آنتروپی با پارامترهای تولید، و تعریف الزامات متدولوژیک برای پایداری سازمانی و ضدحملات (Anti-Injection).
</p>
<h4 id="section-2-1" class="anchored">
۲.۱. مکانیسم‌های ضدتوهم (Anti-Hallucination) و Grounding
</h4>
<dl>
<dt>
ریشه آماری توهم و توزیع احتمال نامناسب
</dt>
<dd>
<p>
توهم ناشی از <strong>طبیعت تولیدی (Generative Nature)</strong> مدل‌هاست؛ مدل همواره به دنبال محتمل‌ترین توکن در فضای آموزشی خود است. <strong>توکن‌های نادرست اما محتمل</strong>، با <strong>احتمال بالا</strong> انتخاب می‌شوند. اگر توزیع احتمال در فضای لاجیت متناسب با واقعیت نباشد، توهم رخ می‌دهد.
</p>
</dd>
<dt>
راهکار RAG (Retrieval-Augmented Generation) و Grounding
</dt>
<dd>
<p>
در RAG، دانش مدل برون‌سپاری می‌شود و مدل وادار می‌گردد که توزیع احتمال خود را با <strong>دانش بیرونی و موثق</strong> شرطی کند. پرامپت شامل دستورالعمل‌هایی برای <strong>اجبار به ارجاع (Grounding)</strong> است. خروجی <span class="math inline">\((\mathbf{y})\)</span> به صورت شرطی بر روی پرسش <span class="math inline">\((\mathbf{x})\)</span> و اسناد بازیابی شده <span class="math inline">\((\mathbf{D})\)</span> تولید می‌شود، که به شدت دقت واقعی (Factual Accuracy) را افزایش می‌دهد:
</p>
<span class="math display">\[
    P(\mathbf{y} | \mathbf{x}, \mathbf{D}, \theta)
    \]</span>
</dd>
</dl>
<h4 id="section-2-2" class="anchored">
۲.۲. کنترل Entropy و Prompt Sensitivity با پارامتر دما
</h4>
<dl>
<dt>
حساسیت به پرامپت (Prompt Sensitivity) و پایداری
</dt>
<dd>
<p>
تغییرات جزئی در ورودی می‌تواند خروجی را به‌طور غیرخطی تغییر دهد. راهکار اصلی، کنترل دقیق <strong>پارامتر دما (<span class="math inline">\(T\)</span>)</strong> است. دما (<span class="math inline">\(T\)</span>) مستقیماً بر روی توزیع <strong>سافت‌مکس (Softmax)</strong> اعمال می‌شود تا توزیع احتمال لاجیت‌ها <span class="math inline">\((\mathbf{z})\)</span> را تغییر دهد:
</p>
<span class="math display">\[
    P(\mathbf{t}_{i+1}|...) = \frac{\exp(\mathbf{z}_{i+1} / T)}{\sum_k \exp(\mathbf{z}_k / T)}
    \]</span>
<p>
تنظیم <strong><span class="math inline">\(T \to 0.0\)</span></strong> (مثلاً <span class="math inline">\(T=0.1\)</span>) توزیع را <strong>تیزتر (Sharper)</strong> کرده، <strong>آنتروپی</strong> (بی‌نظمی یا تصادفی بودن) خروجی را کاهش می‌دهد و پایداری (Reproducibility) را در وظایف حیاتی افزایش می‌دهد. این کار باعث می‌شود مدل بیشتر به محتمل‌ترین توکن‌ها متکی باشد.
</p>
</dd>
</dl>
<h4 id="section-2-3" class="anchored">
۲.۳. الزامات متدولوژیک پرامپت‌های سطح Enterprise
</h4>
<dl>
<dt>
قابلیت ارزیابی (Measurability) و Format Adherence Rate (FAR)
</dt>
<dd>
<p>
خروجی باید در قالبی ساختاریافته (JSON/XML) باشد تا بتواند معیارهای کمی دقیق (مانند <strong>Format Adherence Rate - FAR</strong>) را بپذیرد. <strong>ضرورت استفاده از JSON Schema</strong> برای تعریف رسمی نوع داده‌ها و محدودیت‌ها برای اعتبارسنجی خودکار (Parsability) حیاتی است. <span class="math inline">\(\text{FAR}\)</span> نسبت دفعاتی است که خروجی مدل کاملاً با شمای تعریف شده مطابقت دارد.
</p>
</dd>
<dt>
ایزوله‌سازی (Isolation) و مقابله با Prompt Injection
</dt>
<dd>
<p>
استفاده از <strong>جداکننده‌های قوی و صریح (Explicit Delimiters)</strong> (مثل <code>###CONTEXT###</code> یا تگ‌های XML) برای جداسازی دستورالعمل‌های سیستمی از داده‌های متغیر ورودی کاربر. این ایزوله‌سازی برای جلوگیری از حملات تزریق پرامپت (Prompt Injection) که قصد دارند دستورالعمل‌های اصلی مدل را override کنند، ضروری است.
</p>
</dd>
</dl>
</section>
<section class="section-card">
<h3 id="section-3" class="anchored">
بخش سوم: معماری پیشرفته پرامپت (مدل HARDER) و ساختاردهی خروجی
</h3>
<p style="color: var(--color-text-muted); font-size: 1.1rem;">
تحلیل عناصر شش‌گانه HARDER: الگوی استاندارد و قابل اتکا برای اتوماسیون سازمانی با تأکید بر شمای خروجی رسمی (E).
</p>
<h4 id="section-3-1" class="anchored">
۳.۱. مدل شش‌گانه HARDER (توسعه عناصر و ترتیب حیاتی)
</h4>
<dl>
<dt>
H, A, R: عناصر زمینه‌ساز و کنترلی
</dt>
<dd>
<ul>
<li>
<strong>Hook/Role Definition (H):</strong> تعیین نقش تخصصی مدل (مثلاً “شما یک برنامه‌نویس پایتون ارشد هستید”). این کار فضای فعال‌سازی دانش مدل را به تخصص مربوطه محدود می‌کند.
</li>
<li>
<strong>Argumentation/Context (A):</strong> تزریق داده‌های ورودی، اسناد RAG، و مثال‌های ICL. این عنصر ورودی متغیر (Variable Input) است.
</li>
<li>
<strong>Rules/Constraints (R):</strong> شامل <strong>Guardrails</strong> و محدودیت‌های سختگیرانه برای محتوا و فرآیند (مانند ممنوعیت استفاده از زبان خاص یا الزام به ارجاع).
</li>
</ul>
</dd>
<dt>
D, E, R: عناصر فرآیندی و خروجی اجباری
</dt>
<dd>
<ul>
<li>
<strong>Directive (D):</strong> دستور اصلی و نهایی برای اقدام (مثلاً: “خلاصه کن”، “استخراج کن”). این فرمان بعد از تمام قوانین و شمای خروجی می‌آید تا فوراً به اجرا درآید.
</li>
<li>
<strong>Expected Output Schema (E):</strong> تعریف شمای خروجی رسمی (JSON Schema). این عنصر، اتصال LLM به سیستم‌های پس‌زمینه (Backend Systems) را تضمین می‌کند و <strong>اعتبارسنجی ماشینی</strong> را ممکن می‌سازد.
</li>
<li>
<strong>Return/Final Tag (R):</strong> یک سیگنال صریح (مانند <code>BEGIN_JSON</code>) به مدل برای شروع تولید خروجی، که به ابزارهای پس‌پردازش (Post-Processing) کمک می‌کند تا خروجی خام را به درستی برش دهند.
</li>
</ul>
</dd>
</dl>
<hr>
<h4 id="section-3-2" class="anchored">
۳.۲. شبه‌کد ساخت پرامپت HARDER (ترتیب ثابت و ایزوله‌سازی دقیق)
</h4>
<pre><code class="language-pseudocode">
// ALGORITHM Advanced_Prompt_Architecture_HARDER 
// Designed for Enterprise-Grade Automation. Maintaining this exact order is CRITICAL for Prompt Robustness.

FUNCTION Construct_HARDER_Prompt (Task_Name, Input_Data, Required_Schema_JSON):
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۱. H: Hook/Role Definition (تعیین فعال سازی شناختی)
&nbsp; &nbsp; ROLE_DEFINITION = "You are a Senior Security Analyst. Your task is to classify network threats."
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۲. A: Argumentation/Context (تزریق داده های متغیر)
&nbsp; &nbsp; CONTEXT = f"Analyze the following intrusion log data:\n\n<context_data_logs>\n{Input_Data}\n</context_data_logs>"
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۳. R: Rules/Constraints (Guardrails - کنترل رفتار)
&nbsp; &nbsp; CONSTRAINTS = "R1: Output MUST strictly conform to the provided JSON Schema."
&nbsp; &nbsp; CONSTRAINTS += "R2: Threat classification must be based ONLY on the provided log data (Grounding Rule)."
&nbsp; &nbsp; CONSTRAINTS += "R3: Do not include ANY introductory text, greetings, explanations, or code fencing."
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۴. E: Expected Output Schema (ساختار خروجی اجباری)
&nbsp; &nbsp; JSON_SCHEMA_DEFINITION = Required_Schema_JSON
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۵. D: Directive/Task (فرمان نهایی برای اقدام)
&nbsp; &nbsp; INSTRUCTIONS = "Generate a comprehensive threat analysis and classification based on the data."
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۶. R: Return/Final Tag (سیگنال صریح به مدل برای شروع تولید)
&nbsp; &nbsp; FINAL_TAG = "BEGIN_GENERATION_JSON:"
&nbsp; &nbsp; 
&nbsp; &nbsp; // Assembly Sequence (ترتیب ثابت و ایزوله حیاتی است)
&nbsp; &nbsp; PROMPT = f"""
&nbsp; &nbsp; &nbsp; &nbsp; <task_identifier> {Task_Name} </task_identifier>
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; <role_and_purpose_h>
&nbsp; &nbsp; &nbsp; &nbsp; {ROLE_DEFINITION}
&nbsp; &nbsp; &nbsp; &nbsp; </role_and_purpose_h>
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; <context_data_a>
&nbsp; &nbsp; &nbsp; &nbsp; {CONTEXT}
&nbsp; &nbsp; &nbsp; &nbsp; </context_data_a>
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; <hard_constraints_r>
&nbsp; &nbsp; &nbsp; &nbsp; {CONSTRAINTS}
&nbsp; &nbsp; &nbsp; &nbsp; </hard_constraints_r>
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; <formal_output_schema_e>
&nbsp; &nbsp; &nbsp; &nbsp; {JSON_SCHEMA_DEFINITION}
&nbsp; &nbsp; &nbsp; &nbsp; </formal_output_schema_e>
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; <final_directive_d>
&nbsp; &nbsp; &nbsp; &nbsp; {INSTRUCTIONS}
&nbsp; &nbsp; &nbsp; &nbsp; </final_directive_d>
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; {FINAL_TAG}
&nbsp; &nbsp; """
&nbsp; &nbsp; RETURN PROMPT
</code>
</pre>
</section>
<section class="section-card">
<h3 id="section-4" class="anchored">
بخش چهارم: تکنیک‌های آموزشی درون متنی (ICL) و بهینه‌سازی Few-shot
</h3>
<p style="color: var(--color-text-muted); font-size: 1.1rem;">
تحلیل مکانیسم تطبیق Few-shot، چالش‌های <strong>Ordering Effect</strong> و روش‌های بازیابی افزوده شده (RAG-ICL) با جزئیات فنی شباهت کسینوسی.
</p>
<h4 id="section-4-1" class="anchored">
۴.۱. مکانیسم تطبیق Few-shot و چالش‌های آن
</h4>
<dl>
<dt>
تنظیم دقیق مجازی (Virtual Fine-Tuning) و بایاس موقت
</dt>
<dd>
<p>
ارائه <span class="math inline">\(k\)</span> جفت مثال (<span class="math inline">\(\{\mathbf{x}_i, \mathbf{y}_i\}_{i=1}^k\)</span>) در پرامپت، یک <strong>بایاس موقت</strong> در لایه‌های ترانسفورمر ایجاد می‌کند. مدل با مشاهده جفت‌های ورودی-خروجی، یاد می‌گیرد که توالی ورودی را به یک <strong>نقشه‌برداری (Mapping)</strong> خاصی از خروجی تبدیل کند. این فرآیند بدون به‌روزرسانی پارامترهای وزن مدل انجام می‌شود.
</p>
</dd>
<dt>
چالش Ordering Effect و واریانس خروجی
</dt>
<dd>
<p>
ترتیب مثال‌ها <span class="math inline">\((\mathbf{x}_1, \mathbf{y}_1, \ldots, \mathbf{x}_k, \mathbf{y}_k)\)</span> در بلوک ICL می‌تواند بر دقت نهایی تأثیر غیرخطی و گاهی بسیار زیادی بگذارد. این پدیده باعث ایجاد <strong>واریانس (Variance)</strong> در عملکرد مدل می‌شود. پرامپت‌نویس باید بهترین توالی را از طریق تکنیک‌هایی مانند <strong>Automatic Prompt Engineering (APE)</strong> پیدا کند.
</p>
</dd>
</dl>
<h4 id="section-4-2" class="anchored">
۴.۲. انتخاب نمونه بهینه با RAG-ICL و Vector Database
</h4>
<dl>
<dt>
شباهت کسینوسی و Embeddings
</dt>
<dd>
<p>
برای غلبه بر چالش محدودیت توکن و اطمینان از مرتبط بودن مثال‌ها، از <strong>مدل‌های Embedding</strong> استفاده می‌شود. فرآیند شامل: ۱. تبدیل پرسش و نمونه‌های آموزشی به <strong>بردارهای با ابعاد بالا</strong> <span class="math inline">\((\mathbf{A}, \mathbf{B})\)</span>. ۲. محاسبه <strong>شباهت کسینوسی</strong> برای یافتن نزدیک‌ترین بردار نمونه به بردار پرسش. این روش مرتبط‌ترین <span class="math inline">\(k\)</span> مثال را برای تزریق انتخاب می‌کند.
</p>
<p>
فرمول محاسبه <strong>شباهت کسینوسی</strong> (Normalized Dot Product):
</p>
<span class="math display">\[
    \text{Similarity}(\mathbf{A}, \mathbf{B}) = \cos(\theta) = \frac{\mathbf{A} \cdot \mathbf{B}}{\left \| \mathbf{A} \right \| \left \| \mathbf{B} \right \|}, \quad \text{where } \mathbf{A}, \mathbf{B} \in \mathbb{R}^d
    \]</span>
</dd>
</dl>
<hr>
<h4 id="section-4-3" class="anchored">
۴.۳. شبه‌کد RAG-ICL برای تزریق نمونه‌های بهینه
</h4>
<pre><code class="language-pseudocode">
// ALGORITHM RAG_ICL_Integration (Query, Example_Vector_DB, Max_k)
// هدف: انتخاب بهینه‌ترین k نمونه با بالاترین شباهت معنایی برای تزریق به پرامپت

FUNCTION Calculate_Optimal_FewShot_Block (Query, Example_Vector_DB, Max_k):
&nbsp; &nbsp; // ۱. تبدیل پرس و جو به بردار با مدل Embedding
&nbsp; &nbsp; Query_Vector = Embedding_Model.Encode(Query)
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۲. محاسبه شباهت برای هر نمونه موجود در پایگاه داده برداری
&nbsp; &nbsp; Similarity_Scores = []
&nbsp; &nbsp; FOR EACH Example IN Example_Vector_DB:
&nbsp; &nbsp; &nbsp; &nbsp; Score = Cosine_Similarity(Query_Vector, Example.Vector_Embedding)
&nbsp; &nbsp; &nbsp; &nbsp; Similarity_Scores.APPEND( (Score, Example) )
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; // ۳. مرتب‌سازی (Descending) و انتخاب k بهترین نمونه
&nbsp; &nbsp; Similarity_Scores.SORT_DESCENDING_BY(Score)
&nbsp; &nbsp; Best_k_Examples = Similarity_Scores[1:Max_k]
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۴. ساخت بلوک Few-shot با قالب ثابت و ایزوله‌شده
&nbsp; &nbsp; Few_Shot_Block = "<few_shot_examples_start>\n"
&nbsp; &nbsp; FOR EACH Example IN Best_k_Examples:
&nbsp; &nbsp; &nbsp; &nbsp; Few_Shot_Block += f"""
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <icl_input>: {Example.X} </icl_input>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <icl_output>: {Example.Y} </icl_output>\n
&nbsp; &nbsp; &nbsp; &nbsp; """
&nbsp; &nbsp; Few_Shot_Block += "\n"
&nbsp; &nbsp; RETURN Few_Shot_Block
</few_shot_examples_start></code>
</pre>
</section>
<section class="section-card">
<h3 id="section-5" class="anchored">
بخش پنجم: استدلال پیشرفته: Chain-of-Thought (CoT) و Tree-of-Thought (ToT)
</h3>
<p style="color: var(--color-text-muted); font-size: 1.1rem;">
تحلیل عمق محاسباتی CoT، مکانیسم جستجوی درختی در ToT، روش‌های خوداصلاحی (Self-Correction) و نقش آن‌ها در افزایش دقت.
</p>
<h4 id="section-5-1" class="anchored">
۵.۱. Chain-of-Thought (CoT) و خوداصلاحی (Self-Correction)
</h4>
<dl>
<dt>
تحلیل فرآیند فکری خطی و عمق محاسباتی
</dt>
<dd>
<p>
CoT، مدل را مجبور می‌کند تا فرآیند استدلال را به دنباله خطی از مراحل میانی <span class="math inline">\(\mathbf{z}_1 \to \ldots \to \mathbf{z}_n\)</span> تجزیه کند. این کار به مدل اجازه می‌دهد تا از <strong>حافظه کاری (Working Memory)</strong> بیشتری استفاده کرده و از پدیده <strong>فشردگی استدلال (Argument Compression)</strong> جلوگیری کند. این فرآیند باعث <strong>افزایش طول توالی (Sequence Length)</strong> و به تبع آن، افزایش دقت در مسائل منطقی و ریاضی می‌شود.
</p>
</dd>
<dt>
Self-Refinement / Self-Correction (خوداصلاحی تکراری)
</dt>
<dd>
<p>
تکنیکی پیشرفته که در آن مدل ابتدا پاسخ خام را تولید می‌کند. سپس با یک <strong>پرامپت منتقد (Critic Prompt)</strong> دیگر، پاسخ خود را ارزیابی کرده و خطاها (مانند خطای محاسباتی یا عدم انطباق با Schema) را شناسایی می‌کند. این فرآیند <strong>تکراری (Iterative)</strong> است و با استفاده از <strong>Log-Likelihood</strong> برای ارزیابی اطمینان، پاسخ نهایی را در یک تکرار جدید اصلاح (Refine) می‌کند.
</p>
</dd>
</dl>
<h4 id="section-5-2" class="anchored">
۵.۲. Tree-of-Thought (ToT) و الگوریتم‌های جستجو
</h4>
<dl>
<dt>
Tree-of-Thought (ToT) و جستجوی درختی
</dt>
<dd>
<p>
<strong>جزئیات فنی:</strong> ToT یک فرآیند تصمیم‌گیری <strong>غیرخطی</strong> و پیچیده‌تر است. در هر مرحله، مدل <strong>چندین مسیر استدلال کاندید (Multiple Thought Branches)</strong> را ایجاد می‌کند. یک <strong>تابع ارزیابی (Evaluation Function)</strong> کیفیت هر مسیر را امتیازدهی کرده و با استفاده از الگوریتم‌های جستجو (مانند Breadth-First Search یا Depth-First Search) برای یافتن پاسخ نهایی استفاده می‌شوند. این فرآیند امکان <strong>هرس (Prune)</strong> مسیرهای ناموفق و مدیریت استراتژیک فضای جستجو را فراهم می‌کند.
</p>
</dd>
</dl>
<hr>
<h4 id="section-5-3" class="anchored">
۵.۳. شبه‌کد ساختاردهی Few-shot CoT برای آموزش استدلال تفکیک شده
</h4>
<pre><code class="language-pseudocode">
// ALGORITHM Few_Shot_Chain_of_Thought_Formatter 
// هدف: آموزش مدل برای تفکیک فرآیند فکری از پاسخ نهایی با وضوح بالا

FUNCTION Format_CoT_Example (Input, Thought_Process, Final_Answer):
&nbsp; &nbsp; // ساختاردهی دقیق برای هر مثال CoT با استفاده از تگ‌های XML برای ایزوله‌سازی
&nbsp; &nbsp; RETURN f"""
&nbsp; &nbsp; &nbsp; &nbsp; <cot_example>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <input_query> {Input} </input_query>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <internal_thought_process> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {Thought_Process} 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </internal_thought_process>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <final_answer_only> {Final_Answer} </final_answer_only>
&nbsp; &nbsp; &nbsp; &nbsp; </cot_example>
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; //--------------------------------------------------//
&nbsp; &nbsp; """
&nbsp; &nbsp; 
FUNCTION Construct_CoT_Prompt (Question, CoT_Examples):
&nbsp; &nbsp; PROMPT = "You are a master logician. Always generate content within the defined XML tags.\n"
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۱. تزریق مثال‌های CoT (که الگو را تعریف می کنند)
&nbsp; &nbsp; FOR EACH Example IN CoT_Examples:
&nbsp; &nbsp; &nbsp; &nbsp; PROMPT += Format_CoT_Example(Example.Input, Example.Thought, Example.Answer)
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; // ۲. تزریق پرسش جدید (با الگوی استنتاج)
&nbsp; &nbsp; PROMPT += f"""
&nbsp; &nbsp; &nbsp; &nbsp; <cot_example>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <input_query> {Question} </input_query>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <internal_thought_process>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Model starts generation here...
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </internal_thought_process>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // The model is now conditioned to complete the thought process and final answer.
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; """
&nbsp; &nbsp; 
&nbsp; &nbsp; RETURN PROMPT
</cot_example></code>
</pre>
</section>
<section class="section-card">
<h3 id="section-6" class="anchored">
بخش ششم: توسعه مفاهیم پیشرفته: Guardrails، اعتبارسنجی و بهینه‌سازی تولید
</h3>
<p style="color: var(--color-text-muted); font-size: 1.1rem;">
کنترل دقیق پارامترهای تولید (Temperature, Top-P)، نقش آن‌ها در آنتروپی و پیاده‌سازی مکانیسم‌های دفاعی پس از تولید (Post-Generation) برای اطمینان از صحت ساختاری و محتوایی.
</p>
<h4 id="section-6-1" class="anchored">
۶.۱. پارامترهای تولید (Generation Parameters) و کنترل آماری خروجی
</h4>
<dl>
<dt>
تأثیر ریاضی Top-P (Nucleus Sampling)
</dt>
<dd>
<p>
این پارامتر با استفاده از یک آستانه <strong>تجمعی احتمال</strong> <span class="math inline">\(P \in [0, 1]\)</span>، مجموعه توکن‌های کاندید برای تولید را محدود می‌کند. تنها توکن‌هایی که مجموع احتمالاتشان از <span class="math inline">\(P\)</span> بیشتر است، برای نمونه‌برداری حفظ می‌شوند. این کار به مدل اجازه می‌دهد تا در یک <strong>فضای معنایی محدود و مطمئن</strong> به کاوش بپردازد و تنوع خروجی را به صورت کنترل شده‌ای افزایش دهد.
</p>
<p>
انتخاب توکن بعدی <span class="math inline">\((\mathbf{t}_{i+1})\)</span> از مجموعه <span class="math inline">\(\mathcal{V}_P\)</span>: <span class="math display">\[
    \mathcal{V}_P = \left\{ \mathbf{t} | \sum_{\mathbf{t} \in \mathcal{V}_P} P(\mathbf{t} | \ldots) \ge P \right\}
    \]</span>
</p>
</dd>
</dl>
<h4 id="section-6-2" class="anchored">
۶.۲. پیاده‌سازی Guardrails و اعتبارسنجی سخت‌گیرانه (Post-Generation Validation)
</h4>
<p>
تضمین انطباق با شمای رسمی (JSON Schema) و اصول Grounding در لایه پس از تولید، یک لایه دفاعی قوی در برابر خطاهای مدل فراهم می‌کند.
</p>
<dl>
<dt>
اعتبارسنجی شمای JSON (JSON Schema Validation) و FAR
</dt>
<dd>
<p>
این گاردریل شامل استفاده از کتابخانه‌های سمت سرور (مانند <strong>jsonschema</strong> در پایتون) برای بررسی دقیق خروجی خام مدل در برابر شمای تعریف شده در عنصر <strong>E</strong> (Expected Output Schema) است. شکست در این مرحله به معنای <span class="math inline">\(\text{FAR} \ne 1.0\)</span> و یک خطای بحرانی در اتوماسیون است.
</p>
</dd>
<dt>
بررسی ارجاع (Grounding Check) و Hallucination Detection
</dt>
<dd>
<p>
مکانیسمی برای بررسی خودکار اینکه آیا هر ادعای کلیدی و فکت (Fact) در خروجی مدل، مستقیماً توسط اسناد منبع (Context) پشتیبانی می‌شود یا خیر. این لایه دفاعی اصلی در برابر توهم است که با تکنیک‌های <strong>استخراج فکت (Fact Extraction)</strong> و <strong>مقایسه معنایی (Semantic Comparison)</strong> کار می‌کند.
</p>
</dd>
</dl>
<hr>
<h4 id="section-6-3" class="anchored">
۶.۳. الگوریتم جامع اعتبارسنجی خروجی با Guardrails و کنترل پارامتر
</h4>
<pre><code class="language-pseudocode">
// ALGORITHM LLM_Generation_with_Guardrails (Prompt, Model_API)
// این تابع تضمین می کند که خروجی هم ساختار و هم محتوای مورد انتظار را دارد.

FUNCTION Generate_Content_And_Validate (Prompt, Task_Type, Schema, Source_Text):
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۱. تنظیم دقیق پارامترهای تولید (Based on Task Type)
&nbsp; &nbsp; IF Task_Type == "CRITICAL_REASONING" OR Task_Type == "DATA_EXTRACTION":
&nbsp; &nbsp; &nbsp; &nbsp; SET Temperature = 0.05 // Low Entropy
&nbsp; &nbsp; &nbsp; &nbsp; SET Top_P = 0.95 
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; // ۲. فراخوانی API
&nbsp; &nbsp; Raw_Output = Model_API.Call(prompt = Prompt, temp = Temperature, top_p = Top_P)
&nbsp; &nbsp; 
&nbsp; &nbsp; // ۳. مرحله Post-Processing: برش و پاکسازی خروجی
&nbsp; &nbsp; CLEAN_OUTPUT = Raw_Output.Extract_Content_Between_Tags("BEGIN_GENERATION_JSON", "END_JSON") 
&nbsp; &nbsp; 
&nbsp; &nbsp; // گاردریل ۱: اعتبارسنجی ساختار (JSON Schema Check) - حیاتی برای Parsability
&nbsp; &nbsp; IF Prompt.Requires_JSON_Output:
&nbsp; &nbsp; &nbsp; &nbsp; IF NOT JSON_Validator.Validate(CLEAN_OUTPUT, Schema):
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_ERROR("Guardrail Violation: JSON Schema Mismatch. FAR failure.")
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RETURN "Error: JSON Schema Mismatch (Rollback required)."
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; // گاردریل ۲: بررسی ارجاع (Grounding Check) - ضد توهم
&nbsp; &nbsp; IF Prompt.Requires_Grounding:
&nbsp; &nbsp; &nbsp; &nbsp; IF NOT Grounding_Checker.Verify_Sources(CLEAN_OUTPUT, Source_Text):
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_ERROR("Guardrail Violation: Output is not grounded in source text.")
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RETURN "Error: Hallucination Detected (Need Refinement)."
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; RETURN CLEAN_OUTPUT
</code>
</pre>
</section>
<section class="section-card">
<h3 id="section-7" class="anchored">
بخش هفتم: منابع آکادمیک و تمرین‌های تفصیلی (Prompt Engineering)
</h3>
<p style="color: var(--color-text-muted); font-size: 1.1rem;">
معرفی منابع اصلی مطالعاتی و تمرین‌های عملی سطح بالا برای Prompt Engineering و ارزیابی عملکرد.
</p>
<h4 id="section-7-1" class="anchored">
۷.۱. مراجع آکادمیک و مقالات کلیدی
</h4>
<dl>
<dt>
۱. منابع اصلی و بنیان‌گذار
</dt>
<dd>
<strong>Wei, J. et al.&nbsp;(2022).</strong> <em>Chain-of-Thought Prompting Elicits Reasoning in Large Language Models.</em> (مقاله بنیان‌گذار CoT و تحلیل قابلیت استدلال LLMs).
</dd>
<dd>
<strong>Zhou, D. et al.&nbsp;(2023).</strong> <em>Least-to-Most Prompting Enables Complex Reasoning in Large Language Models.</em> (تحلیل تکنیک استدلال پیشرفته برای مسائل پیچیده).
</dd>
</dl>
<h4 id="section-7-2" class="anchored">
۷.۲. تمرین‌های علمی سطح بالا و مهندسی پرامپت
</h4>
<dl>
<dt>
تمرین‌های پیاده‌سازی و ارزیابی
</dt>
<dd>
<ul>
<li>
<strong>پیاده‌سازی RAG-ICL:</strong> پیاده‌سازی کامل الگوریتم RAG-ICL با استفاده از یک Vector Database و مدل‌های Embedding برای تزریق نمونه‌های بهینه. سنجش تأثیر این تکنیک بر <strong>Factual Recall</strong> مدل.
</li>
<li>
<strong>تحلیل توزیع Softmax:</strong> پیاده‌سازی و نمایش (Plotting) تابع Softmax با دماهای <span class="math inline">\(T=0.1\)</span> و <span class="math inline">\(T=1.0\)</span> بر روی یک بردار لاجیت ثابت و تحلیل بصری توزیع‌های احتمال حاصل و تأثیر آن بر <strong>آنتروپی</strong> (Entropy).
</li>
<li>
<strong>تست FAR:</strong> طراحی یک مجموعه تست (Golden Dataset) برای سنجش <strong>Format Adherence Rate (FAR)</strong> و مقایسه عملکرد یک پرامپت با و بدون عنصر <strong>E</strong> (Expected Output Schema) برای ارزیابی نقش آن در تضمین ساختار خروجی.
</li>
</ul>
</dd>
</dl>
</section>


</main></div>

 <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
 <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><span class="footer-copyright">© 1404 - دانشگاه آزاد اسلامی واحد تهران مرکز</span></p>
</div>   
    <div class="nav-footer-center">
<p><span class="footer-professor-name">استاد : دکتر مریم حاجی اسمعیلی</span></p>
</div>
    <div class="nav-footer-right">
<p><span class="footer-author-name">تهیه و تنظیم: ایلیا نازمهر</span></p>
</div>
  </div>
</footer>




</body></html>